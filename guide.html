<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>以太坊开发学习指南</title>
    <style>
        /* 基础样式 */
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --accent-color: #e74c3c;
            --bg-color: #f9f9f9;
            --text-color: #333;
            --code-bg: #f4f4f4;
            --border-color: #eaeaea;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* 导航栏 */
        .toc {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .toc h2 {
            color: var(--primary-color);
            margin-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }
        
        .toc ul {
            list-style-type: none;
        }
        
        .toc li {
            margin: 8px 0;
        }
        
        .toc a {
            color: var(--secondary-color);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .toc a:hover {
            color: var(--primary-color);
            text-decoration: underline;
        }
        
        /* 标题样式 */
        h1 {
            color: var(--secondary-color);
            margin: 30px 0;
            font-size: 2.5em;
            text-align: center;
        }
        
        h2 {
            color: var(--secondary-color);
            margin: 25px 0 15px 0;
            font-size: 1.8em;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 5px;
        }
        
        h3 {
            color: var(--secondary-color);
            margin: 20px 0 10px 0;
            font-size: 1.4em;
        }
        
        h4 {
            margin: 15px 0 10px 0;
            font-size: 1.2em;
        }
        
        /* 文本内容 */
        p {
            margin-bottom: 15px;
        }
        
        ul, ol {
            margin: 15px 0;
            padding-left: 25px;
        }
        
        li {
            margin-bottom: 5px;
        }
        
        /* 代码样式 */
        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
            background-color: var(--code-bg);
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        pre {
            background-color: var(--code-bg);
            border-radius: 5px;
            padding: 15px;
            overflow: auto;
            margin: 15px 0;
        }
        
        pre code {
            background-color: transparent;
            padding: 0;
        }
        
        /* 高亮部分 */
        .highlight {
            background-color: rgba(52, 152, 219, 0.1);
            border-left: 4px solid var(--primary-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }
        
        /* 表格样式 */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        th {
            background-color: var(--primary-color);
            color: white;
        }
        
        tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.03);
        }
        
        /* 分割线 */
        hr {
            border: none;
            height: 1px;
            background-color: var(--border-color);
            margin: 30px 0;
        }
        
        /* 响应式设计 */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            h2 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <h1>以太坊开发学习指南</h1>
    
    <div class="toc">
        <h2>目录</h2>
        <ul>
            <li><a href="#项目概述">1. 项目概述</a></li>
            <li><a href="#环境准备">2. 环境准备</a></li>
            <li><a href="#solidity智能合约">3. Solidity智能合约</a></li>
            <li><a href="#go后端开发">4. Go后端开发</a></li>
            <li><a href="#项目完整流程">5. 项目完整流程</a></li>
            <li><a href="#进阶主题">6. 进阶主题</a></li>
            <li><a href="#学习路径">7. 学习路径</a></li>
            <li><a href="#常见问题与解决方案">8. 常见问题与解决方案</a></li>
        </ul>
    </div>

    <p>本学习文档基于我们构建的以太坊DApp项目，通过实际代码和详细解释帮助你系统地学习以太坊开发。项目包含Solidity智能合约和Go语言编写的后端，展示了完整的以太坊应用开发流程。</p>

    <h2 id="项目概述">项目概述</h2>
    
    <p>本项目是一个完整的以太坊DApp示例，包括：</p>
    
    <ul>
        <li><strong>代币系统</strong>：实现了ERC20标准的代币合约</li>
        <li><strong>投票系统</strong>：基于代币的去中心化投票机制</li>
        <li><strong>Go后端</strong>：与以太坊区块链交互的完整后端实现</li>
    </ul>
    
    <p>项目结构：</p>
    <pre><code>.
├── contracts/                 # Solidity智能合约
│   ├── Token.sol              # ERC20代币合约
│   └── Voting.sol             # 投票合约
│
├── go-ethereum-dapp/          # Go后端
│   ├── cmd/                   # 命令行程序
│   │   └── main.go            # 主程序
│   │
│   └── pkg/                   # 包
│       ├── config/            # 配置
│       ├── contracts/         # 合约绑定
│       ├── ethereum/          # 以太坊客户端
│       └── services/          # 服务层
│
├── .env.example               # 环境变量示例
└── README.md                  # 说明文档</code></pre>

    <h2 id="环境准备">环境准备</h2>
    
    <p>在开始开发前，需要设置适当的环境：</p>
    
    <ol>
        <li><strong>安装Go</strong>：1.16+版本</li>
        <li><strong>安装以太坊开发工具</strong>：
            <ul>
                <li>Ganache或Hardhat (本地区块链模拟器)</li>
                <li>Solidity编译器 (solc)</li>
                <li>Metamask浏览器插件 (可选)</li>
            </ul>
        </li>
        <li><strong>项目依赖</strong>：
            <pre><code># 使用go mod安装依赖
go mod download</code></pre>
        </li>
        <li><strong>环境配置</strong>：
            从<code>.env.example</code>创建<code>.env</code>文件，配置以下内容：
            <pre><code>ETHEREUM_URL=http://localhost:8545
CHAIN_ID=1337
PRIVATE_KEY=你的私钥</code></pre>
        </li>
    </ol>

    <h2 id="solidity智能合约">Solidity智能合约</h2>
    
    <h3 id="erc20代币合约">ERC20代币合约</h3>
    
    <p><code>Token.sol</code>是一个基于ERC20标准的代币合约。ERC20是以太坊上最常用的代币标准之一，定义了代币合约的基本接口。</p>
    
    <h4>核心功能</h4>
    
    <ol>
        <li><strong>代币属性</strong>：
            <pre><code>string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;</code></pre>
        </li>
        
        <li><strong>余额和授权管理</strong>：
            <pre><code>mapping(address => uint256) public balanceOf;
mapping(address => mapping(address => uint256)) public allowance;</code></pre>
        </li>
        
        <li><strong>事件定义</strong>：
            <pre><code>event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed owner, address indexed spender, uint256 value);</code></pre>
        </li>
        
        <li><strong>转账逻辑</strong>：
            <pre><code>function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0), "不能转账到零地址");
    require(balanceOf[msg.sender] >= _value, "余额不足");
    
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;
    
    emit Transfer(msg.sender, _to, _value);
    return true;
}</code></pre>
        </li>
    </ol>
    
    <h4>学习要点</h4>
    
    <ul>
        <li><strong>状态变量与存储</strong>：了解如何使用映射存储用户余额和授权信息</li>
        <li><strong>函数修饰符</strong>：public、view等修饰符的使用</li>
        <li><strong>事件发射</strong>：使用事件记录链上活动</li>
        <li><strong>安全检查</strong>：使用require进行条件验证</li>
        <li><strong>状态修改</strong>：如何安全地修改合约状态</li>
    </ul>
    
    <h3 id="投票合约">投票合约</h3>
    
    <p><code>Voting.sol</code>展示了一个更复杂的智能合约案例，实现了基于代币持有量的投票系统。</p>
    
    <h4>核心功能</h4>
    
    <ol>
        <li><strong>数据结构</strong>：
            <pre><code>struct Option {
    string name;       // 选项名称
    uint256 voteCount; // 得票数
}</code></pre>
        </li>
        
        <li><strong>状态管理</strong>：
            <pre><code>// 保存所有投票选项
mapping(uint256 => Option) public options;
// 记录每个地址是否已投票
mapping(address => bool) public hasVoted;
// 记录每个地址投票的选项
mapping(address => uint256) public votedOption;</code></pre>
        </li>
        
        <li><strong>投票逻辑</strong>：
            <pre><code>function vote(uint256 _optionId) public {
    require(block.timestamp < endTime, "投票已结束");
    require(_optionId < optionsCount, "无效的选项ID");
    require(!hasVoted[msg.sender], "已经投过票了");
    require(tokenContract.balanceOf(msg.sender) > 0, "需要持有代币才能投票");
    
    // 记录投票信息
    hasVoted[msg.sender] = true;
    votedOption[msg.sender] = _optionId;
    
    // 增加选项票数（票数权重与持有代币数量成正比）
    uint256 voteWeight = tokenContract.balanceOf(msg.sender);
    options[_optionId].voteCount += voteWeight;
    
    // 触发投票事件
    emit Voted(msg.sender, _optionId);
}</code></pre>
        </li>
    </ol>
    
    <h4>学习要点</h4>
    
    <ul>
        <li><strong>合约间调用</strong>：如何在合约中调用其他合约的方法</li>
        <li><strong>结构体使用</strong>：定义和使用复杂数据结构</li>
        <li><strong>时间控制</strong>：使用区块时间控制合约逻辑</li>
        <li><strong>加权投票</strong>：实现基于代币持有量的投票权重</li>
        <li><strong>动态存储</strong>：使用映射高效存储动态数据</li>
    </ul>
    
    <h2 id="go后端开发">Go后端开发</h2>
    
    <h3 id="配置管理">配置管理</h3>
    
    <p><code>config/config.go</code>管理应用程序配置，演示了如何处理环境变量和配置文件。</p>
    
    <pre><code>// LoadConfig 加载配置信息
func LoadConfig() (*Config, error) {
    // 获取项目根目录
    _, b, _, _ := runtime.Caller(0)
    basePath := filepath.Join(filepath.Dir(b), "../..")
    
    // 加载.env文件
    err := godotenv.Load(filepath.Join(basePath, ".env"))
    if err != nil {
        // 如果.env文件不存在，继续执行，使用环境变量
    }
    
    // 默认使用本地开发网络
    ethereumURL := getEnv("ETHEREUM_URL", "http://localhost:8545")
    chainIDStr := getEnv("CHAIN_ID", "1337") // 默认使用Ganache的链ID
    
    // 解析链ID
    chainID := new(big.Int)
    chainID.SetString(chainIDStr, 10)
    
    // 创建配置
    cfg := &Config{
        EthereumNetworkURL:    ethereumURL,
        ChainID:               chainID,
        GasLimit:              uint64(3000000),                  // 默认燃料限制
        GasPrice:              big.NewInt(20000000000),          // 默认20 Gwei
        TokenContractAddress:  getEnv("TOKEN_CONTRACT_ADDRESS", ""),
        VotingContractAddress: getEnv("VOTING_CONTRACT_ADDRESS", ""),
        PrivateKey:            getEnv("PRIVATE_KEY", ""),
    }
    
    return cfg, nil
}</code></pre>
    
    <h4>学习要点</h4>
    
    <ul>
        <li><strong>环境变量管理</strong>：读取和处理系统环境变量</li>
        <li><strong>配置默认值</strong>：为必要配置提供合理默认值</li>
        <li><strong>路径处理</strong>：获取和处理文件路径</li>
        <li><strong>类型转换</strong>：字符串到正确数据类型的转换</li>
    </ul>
    
    <h3 id="以太坊客户端">以太坊客户端</h3>
    
    <p><code>ethereum/client.go</code>封装了与以太坊网络的交互逻辑，展示如何连接区块链和执行基本操作。</p>
    
    <pre><code>// CreateTransactionOpts 创建交易选项
func (c *Client) CreateTransactionOpts(privateKey *ecdsa.PrivateKey, gasLimit uint64, gasPrice *big.Int) (*bind.TransactOpts, error) {
    // 获取链ID
    chainID, err := c.GetChainID()
    if err != nil {
        return nil, err
    }
    
    // 创建交易选项
    auth, err := bind.NewKeyedTransactorWithChainID(privateKey, chainID)
    if err != nil {
        return nil, err
    }
    
    // 如果未指定燃料价格，获取建议的燃料价格
    if gasPrice == nil {
        gasPrice, err = c.GetSuggestedGasPrice()
        if err != nil {
            return nil, err
        }
    }
    
    // 设置燃料限制和燃料价格
    auth.GasLimit = gasLimit
    auth.GasPrice = gasPrice
    
    // 获取账户nonce
    nonce, err := c.GetTransactionCount(auth.From)
    if err != nil {
        return nil, err
    }
    auth.Nonce = big.NewInt(int64(nonce))
    
    return auth, nil
}</code></pre>
    
    <h4>学习要点</h4>
    
    <ul>
        <li><strong>以太坊客户端初始化</strong>：连接到以太坊网络</li>
        <li><strong>私钥管理</strong>：安全处理私钥并用于签名交易</li>
        <li><strong>交易参数设置</strong>：GasLimit、GasPrice和Nonce的设置</li>
        <li><strong>区块链状态查询</strong>：获取账户余额、交易计数等</li>
        <li><strong>交易创建与发送</strong>：构建和发送交易到网络</li>
    </ul>
    
    <h3 id="合约绑定">合约绑定</h3>
    
    <p><code>contracts</code>目录包含从Solidity生成的Go绑定代码，演示如何在Go中与智能合约交互。</p>
    
    <pre><code>// SimpleToken Go绑定结构体
type SimpleToken struct {
    address common.Address     // 合约地址
    backend bind.ContractBackend // 合约后端
    abi     abi.ABI           // 合约ABI
}

// DeploySimpleToken 部署新的代币合约
func DeploySimpleToken(auth *bind.TransactOpts, backend bind.ContractBackend, 
                        name string, symbol string, decimals uint8, 
                        initialSupply *big.Int) (common.Address, *types.Transaction, *SimpleToken, error) {
    // 解析ABI
    parsed, err := abi.JSON(strings.NewReader(TokenABI))
    if err != nil {
        return common.Address{}, nil, nil, err
    }
    
    // 编码部署参数
    input, err := parsed.Pack("", name, symbol, decimals, initialSupply)
    if err != nil {
        return common.Address{}, nil, nil, err
    }
    
    // 部署合约
    address, tx, err := bind.DeployContract(auth, parsed, input, backend)
    if err != nil {
        return common.Address{}, nil, nil, err
    }
    
    // 创建合约实例
    contract := &SimpleToken{
        address: address,
        backend: backend,
        abi:     parsed,
    }
    
    return address, tx, contract, nil
}</code></pre>
    
    <h4>学习要点</h4>
    
    <ul>
        <li><strong>ABI解析</strong>：解析智能合约二进制接口(ABI)</li>
        <li><strong>参数打包</strong>：将Go类型打包成EVM可理解的数据</li>
        <li><strong>合约部署</strong>：将字节码部署到区块链</li>
        <li><strong>方法调用</strong>：调用合约的只读和状态变更方法</li>
        <li><strong>事件过滤与监听</strong>：监听和处理合约事件</li>
    </ul>
    
    <h3 id="服务层">服务层</h3>
    
    <p><code>services</code>目录实现了业务逻辑层，将低级合约交互转化为易用的服务接口。</p>
    
    <pre><code>// TokenService 代币服务
type TokenService struct {
    client      *ethereum.Client     // 以太坊客户端
    config      *config.Config       // 配置
    tokenContract *contracts.SimpleToken // 代币合约
}

// Transfer 转账代币
func (s *TokenService) Transfer(privateKey string, to common.Address, amount *big.Int) (*types.Transaction, error) {
    if s.tokenContract == nil {
        return nil, fmt.Errorf("合约未加载")
    }
    
    // 解析私钥
    pk, err := ethereum.PrivateKeyFromHex(privateKey)
    if err != nil {
        return nil, fmt.Errorf("解析私钥失败: %w", err)
    }
    
    // 创建交易选项
    auth, err := s.client.CreateTransactionOpts(pk, s.config.GasLimit, s.config.GasPrice)
    if err != nil {
        return nil, fmt.Errorf("创建交易选项失败: %w", err)
    }
    
    // 转账代币
    tx, err := s.tokenContract.Transfer(auth, to, amount)
    if err != nil {
        return nil, fmt.Errorf("转账代币失败: %w", err)
    }
    
    return tx, nil
}</code></pre>
    
    <h4>学习要点</h4>
    
    <ul>
        <li><strong>服务抽象</strong>：创建易用的高级API</li>
        <li><strong>错误处理</strong>：适当的错误处理和信息传递</li>
        <li><strong>依赖注入</strong>：通过构造函数注入依赖</li>
        <li><strong>业务逻辑封装</strong>：将底层细节封装在服务中</li>
        <li><strong>交易管理</strong>：处理交易生命周期</li>
    </ul>
    
    <h3 id="主程序流程">主程序流程</h3>
    
    <p><code>cmd/main.go</code>展示了完整的应用程序流程，从初始化到合约部署、交互和查询结果。</p>
    
    <pre><code>// runDemo 运行完整演示
func runDemo(ctx context.Context, client *ethereum.Client, cfg *config.Config) error {
    // ... 初始化代码 ...
    
    // 部署代币合约
    if cfg.TokenContractAddress == "" {
        log.Println("正在部署代币合约...")
        // 部署代币合约
        tokenAddress, tokenTx, err = tokenService.DeployContract(
            cfg.PrivateKey,
            "示例代币",     // 名称
            "EXT",      // 符号
            18,         // 精度
            big.NewInt(1000000), // 初始供应量
        )
        // ... 处理结果 ...
    }
    
    // 转账代币给测试账户
    log.Printf("转账100代币到地址: %s", testAddress.Hex())
    
    transferAmount := new(big.Int).Mul(big.NewInt(100), new(big.Int).Exp(big.NewInt(10), big.NewInt(int64(decimals)), nil))
    transferTx, err := tokenService.Transfer(cfg.PrivateKey, testAddress, transferAmount)
    // ... 处理结果 ...
    
    // 部署投票合约
    if cfg.VotingContractAddress == "" {
        log.Println("正在部署投票合约...")
        
        // 投票选项
        voteOptions := []string{"选项A", "选项B", "选项C"}
        
        // 部署投票合约
        votingAddress, votingTx, err = votingService.DeployContract(
            cfg.PrivateKey,
            "示例投票",                 // 投票主题
            tokenAddress,            // 代币合约地址
            big.NewInt(10),         // 持续时间（分钟）
            voteOptions,            // 投票选项
        )
        // ... 处理结果 ...
    }
    
    // 进行投票
    log.Println("进行投票...")
    voteTx, err := votingService.Vote(cfg.PrivateKey, big.NewInt(0)) // 投票给选项A
    // ... 处理结果 ...
    
    // 查询结果
    winningID, winningName, winningVotes, err := votingService.GetWinningOption()
    // ... 输出结果 ...
    
    return nil
}</code></pre>
    
    <h4>学习要点</h4>
    
    <ul>
        <li><strong>应用程序生命周期</strong>：初始化、运行和优雅关闭</li>
        <li><strong>上下文管理</strong>：使用context控制应用生命周期</li>
        <li><strong>交易流程</strong>：从创建到确认的完整交易流程</li>
        <li><strong>异步处理</strong>：处理区块链的异步特性</li>
        <li><strong>数据转换</strong>：不同单位和格式的转换</li>
    </ul>
    
    <div class="highlight">
        <h2 id="项目完整流程">项目完整流程</h2>
        
        <p>通过本项目，你可以学习到完整的以太坊开发流程：</p>
        
        <ol>
            <li><strong>智能合约开发</strong>
                <ul>
                    <li>编写符合标准的代币合约</li>
                    <li>实现基于代币的投票系统</li>
                    <li>合约间交互与依赖</li>
                </ul>
            </li>
            
            <li><strong>Go后端开发</strong>
                <ul>
                    <li>连接以太坊网络</li>
                    <li>部署智能合约</li>
                    <li>发送交易与监听事件</li>
                    <li>查询合约状态</li>
                </ul>
            </li>
            
            <li><strong>完整应用功能</strong>
                <ul>
                    <li>代币发行与转账</li>
                    <li>权重投票机制</li>
                    <li>结果统计与查询</li>
                </ul>
            </li>
        </ol>
    </div>
    
    <h2 id="进阶主题">进阶主题</h2>
    
    <p>在掌握基础项目后，可以探索以下进阶主题：</p>
    
    <ol>
        <li><strong>合约升级模式</strong>
            <ul>
                <li>代理合约设计</li>
                <li>数据与逻辑分离</li>
                <li>安全升级机制</li>
            </ul>
        </li>
        
        <li><strong>Gas优化</strong>
            <ul>
                <li>存储优化</li>
                <li>循环优化</li>
                <li>变量打包</li>
            </ul>
        </li>
        
        <li><strong>安全审计</strong>
            <ul>
                <li>常见漏洞防范</li>
                <li>形式化验证</li>
                <li>测试覆盖率</li>
            </ul>
        </li>
        
        <li><strong>扩展功能</strong>
            <ul>
                <li>NFT实现</li>
                <li>去中心化交易所(DEX)</li>
                <li>链下计算与预言机</li>
            </ul>
        </li>
    </ol>
    
    <h2 id="学习路径">学习路径</h2>
    
    <p>从初学者到专业开发者的建议学习路径：</p>
    
    <ol>
        <li><strong>基础阶段</strong> (1-2个月)
            <ul>
                <li>以太坊和区块链基础知识</li>
                <li>Solidity语法和基本合约</li>
                <li>Web3与区块链交互基础</li>
            </ul>
        </li>
        
        <li><strong>实践阶段</strong> (2-4个月)
            <ul>
                <li>复现和理解本项目代码</li>
                <li>扩展项目功能</li>
                <li>尝试不同的合约标准和模式</li>
            </ul>
        </li>
        
        <li><strong>进阶阶段</strong> (4-12个月)
            <ul>
                <li>安全最佳实践</li>
                <li>优化技术</li>
                <li>DeFi协议分析和实现</li>
            </ul>
        </li>
        
        <li><strong>专业阶段</strong> (1年以上)
            <ul>
                <li>复杂系统设计</li>
                <li>协议创新</li>
                <li>审计和安全专业化</li>
            </ul>
        </li>
    </ol>
    
    <h2 id="常见问题与解决方案">常见问题与解决方案</h2>
    
    <ol>
        <li><strong>Gas费用过高</strong>
            <ul>
                <li>优化合约代码</li>
                <li>批量处理交易</li>
                <li>选择合适的交易时机</li>
            </ul>
        </li>
        
        <li><strong>交易确认慢</strong>
            <ul>
                <li>实现适当的等待和超时机制</li>
                <li>提供取消和替代交易选项</li>
                <li>实现交易状态追踪</li>
            </ul>
        </li>
        
        <li><strong>合约升级</strong>
            <ul>
                <li>使用代理模式实现可升级合约</li>
                <li>保持状态数据与逻辑分离</li>
                <li>实现治理机制控制升级</li>
            </ul>
        </li>
        
        <li><strong>安全问题</strong>
            <ul>
                <li>实施严格的输入验证</li>
                <li>遵循检查-效果-交互模式</li>
                <li>进行全面测试和审计</li>
            </ul>
        </li>
    </ol>
    
    <hr>
    
    <p>本学习文档基于我们的以太坊DApp项目，旨在提供一个系统性的学习路径。通过理解和扩展这个项目，你可以逐步掌握以太坊开发的各个方面，最终成为一名专业的区块链开发者。</p>
    
    <p style="text-align: center; font-style: italic; margin-top: 30px;">Happy coding!</p>
</body>
</html>